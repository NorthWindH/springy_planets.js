<!DOCTYPE html>
<html lang="en">
    <head>
        <title>three.js webgl - geometry - cube</title>
        <meta charset="utf-8">
        <style>
            body {
                margin: 0px;
                background-color: #000000;
                overflow: hidden;
            }
        </style>
    </head>
    <body>

        <script src="three.min.js"></script>
        <script src="FirstPersonControls.js"></script>

        <script>
            var camera, scene, renderer, planetarium, shooter, light, grid,
                gridLights, controls, projector, simulator;
            var SHADOW_MAP_WIDTH = 2048, SHADOW_MAP_HEIGHT = 1024;
            var fireCooldown = 0.25;
            var targetPos = new THREE.Vector3(0, 0, -5);
            var clock = new THREE.Clock();
            var lifetime = 20, fireSpeed = 5, linearDampening = 0.5;
            var gridX = 5, gridY = 5, gridZ = 5, gridSegLength = 5, gridThickness = 0.05;
            var lgridX = 2, lgridY = 2, lgridZ = 2, lgridSegLength = 12.5, intensity = 1, distance = 12.5;
            var holdDistance = 2;

            var Planetarium = function(options){
                this.lifetime = options.lifetime;
                this.fireSpeed = options.fireSpeed;
                this.linearDampening = options.linearDampening;
                this.scene = options.scene;

                this.planets = new Array();

                var texture = THREE.ImageUtils.loadTexture( 'textures/planets/moon_1024.jpg' );
                texture.anisotropy = renderer.getMaxAnisotropy();
                var specTex = THREE.ImageUtils.loadTexture( 'textures/planets/moon_spec_1024.jpg' );
                specTex.anisotropy = renderer.getMaxAnisotropy();
                var bumpTex = THREE.ImageUtils.loadTexture( 'textures/planets/moon_bump_1024.jpg' );
                bumpTex.anisotropy = renderer.getMaxAnisotropy();

                this.planetMaterial = new THREE.MeshPhongMaterial( {
                    map: texture,
                    specularMap: specTex
                });

                this.planetGeometry = new THREE.SphereGeometry( 0.5, 32, 32 );
            };

            Planetarium.prototype.firePlanet = function(position, direction){
                var material = this.planetMaterial.clone();
                var colorHex = 0x777777 + Math.floor(Math.random() * 0x666666);
                material.color.setHex(colorHex);
                material.ambient.setHex(colorHex);
                var planet = new THREE.Mesh(this.planetGeometry, material);
                scene.add(planet);
                this.planets.push(planet);

                planet.lifetime = this.lifetime;
                planet.position = position;
                planet.velocity = direction.clone();
                planet.velocity.multiplyScalar(this.fireSpeed);
                planet.castShadow = true;
                planet.receiveShadow = true;
            };

            Planetarium.prototype.update = function(delta){
                var planets = this.planets;
                var toRemove = new Array();
                for (var i = 0, end = planets.length; i < end; ++i) {
                    var planet = planets[i];
                    planet.lifetime -= delta;
                    if (planet.lifetime <= 0) {
                        this.scene.remove(planet);
                        toRemove.splice(0,0,i);
                    } else {
                        // Integrate forward
                        planet.velocity.multiplyScalar(1 - (this.linearDampening * delta));
                        planet.position.addSelf(planet.velocity.clone().multiplyScalar(delta));
                        var scale = planet.lifetime / this.lifetime;
                        planet.scale.set(scale, scale, scale);
                    }
                }
                for (var i = 0, end = toRemove.length; i < end; ++i) {
                    this.planets[i].deallocate();
                    this.planets.splice(toRemove[i], 1);
                }
            };

            var SpringSimulator = function(options){
                this.objects = options.objects;
                this.restDistance = options.restDistance;
                this.constant = options.constant;
            };
            SpringSimulator.prototype.setFocus = function(object){
                this.focus = object;
            };
            SpringSimulator.prototype.setTarget = function(targetPosition){
                this.target = targetPosition.clone();
            };
            SpringSimulator.prototype.update = function(delta){
                var focus = this.focus;

                // Are we focussed and object still alive?
                if (focus && focus.lifetime > 0) {

                    // Move object toward target
                    if (this.target) {
                        var posSoon = focus.position.clone().addSelf(focus.velocity.clone().multiplyScalar(0.5));
                        var force = new THREE.Vector3();
                        force.sub(this.target, posSoon).multiplyScalar(4);

                        // Yep, integrating velocity right here :)
                        focus.velocity.addSelf(force.multiplyScalar(delta));
                    }
                } else {
                    this.setFocus(null);
                }
            };

            var Shooter = function(options){
                this.onFire = options.onFire;
                this.cooldown = options.cooldown;

                this.cooldownRemaining = 0;
                this.firing = false;
            };
            Shooter.prototype.fireStart = function(){
                this.firing = true;
            };
            Shooter.prototype.fireStop = function(){
                this.firing = false;
            };
            Shooter.prototype.update = function(delta){
                this.cooldownRemaining -= delta;
                this.cooldownRemaining = Math.max(0, this.cooldownRemaining);
                if (this.firing && this.cooldownRemaining <= 0) {
                    this.cooldownRemaining = this.cooldown;
                    this.onFire();
                }
            };

            var VolumeGrid = function(options) {
                var segmentLength = options.segmentLength,
                    x = options.x,
                    y = options.y,
                    z = options.z,
                    thickness = options.thickness;

                var segMesh = new THREE.CubeGeometry(1, 1, 1);
                var outMesh = new THREE.Geometry();

                var material = new THREE.MeshPhongMaterial( {
                    color: 0xFFFFFF,
                    opacity: 0.4
                });

                var startX = -0.5 * x * segmentLength;
                var startY = -0.5 * y * segmentLength;
                var startZ = -0.5 * z * segmentLength;
                var position = new THREE.Vector3();
                for (var i = 0; i <= x; ++i) {
                    for (var j = 0; j <= y; ++j) {
                        for (var k = 0; k <= z; ++k) {
                            var segx = new THREE.Mesh( segMesh );
                            var segy = new THREE.Mesh( segMesh );
                            var segz = new THREE.Mesh( segMesh );

                            segx.scale.y = thickness;
                            segx.scale.z = thickness;
                            segy.scale.x = thickness;
                            segy.scale.z = thickness;
                            segz.scale.x = thickness;
                            segz.scale.y = thickness;

                            segx.scale.x = segmentLength;
                            segy.scale.y = segmentLength;
                            segz.scale.z = segmentLength;

                            position.set(
                                startX + i * segmentLength,
                                startY + j * segmentLength,
                                startZ + k * segmentLength
                            );
                            segx.position.copy(position);
                            segy.position.copy(position);
                            segz.position.copy(position);

                            THREE.GeometryUtils.merge(outMesh, segx);
                            THREE.GeometryUtils.merge(outMesh, segy);
                            THREE.GeometryUtils.merge(outMesh, segz);
                        }
                    }
                }

                THREE.Mesh.call(this, outMesh, material);
            };
            VolumeGrid.prototype = Object.create( THREE.Mesh.prototype );

            var GridLights = function(options) {
                THREE.Object3D.call(this);

                var segmentLength = options.segmentLength,
                    x = options.x,
                    y = options.y,
                    z = options.z,
                    intensity = options.intensity,
                    distance = options.distance,
                    scene = options.scene;

                var lightType = 0;
                var startX = -0.5 * x * segmentLength;
                var startY = -0.5 * y * segmentLength;
                var startZ = -0.5 * z * segmentLength;
                for (var i = 0; i <= x; ++i) {
                    for (var j = 0; j <= y; ++j) {
                        for (var k = 0; k <= z; ++k) {
                            var lightColor;
                            switch (lightType) {
                                case 0:
                                    lightColor = 0xFF0000;
                                    break;
                                case 1:
                                    lightColor = 0x00FF00;
                                    break;
                                case 2:
                                    lightColor = 0x0000FF;
                                    break;
                            }
                            ++lightType;
                            lightType = lightType % 3;
                            var light = new THREE.PointLight(
                                lightColor,
                                intensity,
                                distance
                            );
                            light.position.set(
                                startX + i * segmentLength,
                                startY + j * segmentLength,
                                startZ + k * segmentLength
                            );
                            this.add(light);
                            scene.add(light);
                        }
                    }
                }
            };
            GridLights.prototype = Object.create( THREE.Object3D.prototype );

            init();
            animate();

            function init() {

                renderer = new THREE.WebGLRenderer();
                renderer.setSize( window.innerWidth, window.innerHeight );
                renderer.shadowMapEnabled = true;
                renderer.shadowMapSoft = true;
                document.body.appendChild( renderer.domElement );

                camera = new THREE.PerspectiveCamera( 70, window.innerWidth / window.innerHeight, 0.1, 300 );

                controls = new THREE.FirstPersonControls( camera );
                controls.movementSpeed = 2;
                controls.lookSpeed = 2 * Math.PI;

                scene = new THREE.Scene();

                planetarium = new Planetarium({
                    scene: scene,
                    lifetime: lifetime,
                    fireSpeed: fireSpeed,
                    linearDampening: linearDampening
                });
                shooter = new Shooter({
                    cooldown: fireCooldown,
                    onFire: onFire
                });
                simulator = new SpringSimulator({
                    objects: planetarium.planets,
                    restDistance: 1,
                    constant: 1
                });

                projector = new THREE.Projector();
                light = new THREE.SpotLight( 0xFFFFFF, 1, 0, Math.PI, 1 );
                light.castShadow = true;
                light.shadowCameraNear = camera.near;
                light.shadowCameraFar = camera.far;
                light.shadowCameraFov = 50;
                light.shadowBias = 0.0001;
                light.shadowDarkness = 0.5;

                light.shadowMapWidth = SHADOW_MAP_WIDTH;
                light.shadowMapHeight = SHADOW_MAP_HEIGHT;

                light.position = camera.position.clone();
                light.target.position = targetPos;
                scene.add(light);
                var ambient = new THREE.AmbientLight(0x444444);
                scene.add( ambient );

                grid = new VolumeGrid({
                    segmentLength: gridSegLength,
                    x: gridX,
                    y: gridY,
                    z: gridZ,
                    thickness: gridThickness
                });
                gridLights = new GridLights({
                    segmentLength: lgridSegLength,
                    x: lgridX,
                    y: lgridY,
                    z: lgridZ,
                    intensity: intensity,
                    distance: distance,
                    scene: scene
                });
                scene.add(grid);
                scene.add(gridLights);


                window.addEventListener( 'resize', onWindowResize, false );
                renderer.domElement.addEventListener( 'mousedown', onMouseDown, false );
                renderer.domElement.addEventListener( 'mouseup', onMouseUp, false );

            };

            function onWindowResize() {

                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();

                renderer.setSize( window.innerWidth, window.innerHeight );

            };

            function onFire() {
                var position = camera.position.clone();
                var direction = new THREE.Vector3(Math.random() * 0.5 - 0.25, Math.random() * 0.5 - 0.25, -1);
                camera.matrixWorld.rotateAxis(direction);
                planetarium.firePlanet(position, direction);
            };

            function onMouseDown(event) {
                if (event.which === 1) {
                    shooter.fireStart();
                } else {

                    // Perform intersection
                    var mouse = new THREE.Vector2();
                    mouse.x = ( event.clientX / window.innerWidth ) * 2 - 1;
                    mouse.y = - ( event.clientY / window.innerHeight ) * 2 + 1;

                    var vector = new THREE.Vector3( mouse.x, mouse.y, 0.5 );
                    projector.unprojectVector( vector, camera );

                    var ray = new THREE.Ray( camera.position, vector.subSelf( camera.position ).normalize() );
                    var intersects = ray.intersectObjects( planetarium.planets );

                    if ( intersects.length > 0 ) {

                        controls.enabled = false;

                        var planet = intersects[ 0 ].object;
                        simulator.setFocus(planet);
                    }
                }
            };

            function onMouseUp() {
                if (event.which === 1) {
                    shooter.fireStop();
                } else {
                    simulator.setFocus(null);
                }
            };

            function animate() {

                var delta = clock.getDelta();

                requestAnimationFrame( animate );

                light.position.add(camera.position, camera.matrixRotationWorld.multiplyVector3(new THREE.Vector3(0,1,1)));
                light.target.position = camera.matrixWorld.multiplyVector3(targetPos.clone());

                // Reset focus target if currently holding
                if (simulator.focus) {
                    simulator.setTarget(camera.matrixWorld.multiplyVector3(new THREE.Vector3(0, 0, -holdDistance)));
                }

                shooter.update(delta);
                simulator.update(delta);
                planetarium.update(delta);
                controls.update(delta);
                renderer.render( scene, camera );

            };

        </script>

    </body>
</html>
